! vim:ft=fortran
#:include 'defs.fypp'

module plumed_module
  use iso_c_binding
  implicit none

  private
  public :: plumed_f_create
  public :: plumed_f_create_dlopen
  public :: plumed_f_create_reference
  public :: plumed_f_create_invalid
  public :: plumed_f_cmd
  public :: plumed_f_finalize
  public :: plumed_f_installed
  public :: plumed_f_valid
  public :: plumed_f_use_count
  public :: plumed_f_global
  public :: plumed_f_ginitialized
  public :: plumed_f_gcreate
  public :: plumed_f_gcmd
  public :: plumed_f_gfinalize
  public :: plumed_f_gvalid

  public :: plumed

  type plumed
    character(kind=c_char,len=32), private :: handle
    logical,                       private :: initialized = .false.
  contains 
    private
    generic, public :: cmd => &
#: for t in types
#: for ik in range(len(kinds[t]))
#: for r in range(maxrank+1)
    pl_cmd_${t}$_${ik}$_${r}$, &
#: endfor
#: endfor
#: endfor
    pl_cmd, &
    pl_cmd_char

#: for t in types
#: for ik in range(len(kinds[t]))
#: for r in range(maxrank+1)
    procedure :: pl_cmd_${t}$_${ik}$_${r}$
#: endfor
#: endfor
#: endfor
    procedure :: pl_cmd
    procedure :: pl_cmd_char

    procedure, public :: create => pl_create
    procedure, public :: create_reference => pl_create_reference
    procedure, public :: create_dlopen => pl_create_dlopen
    procedure, public :: create_invalid => pl_create_invalid
    procedure, public :: finalize => pl_finalize
    generic,   public :: assignment(=) => pl_assign
    final     :: pl_destructor
    procedure, public :: valid => pl_valid
    procedure, public :: use_count => pl_use_count
    procedure :: pl_assign
  end type plumed

  interface
    subroutine plumed_f_create(c) bind(C)
      import
      character(kind=c_char), intent(out) :: c(32)
    end subroutine plumed_f_create
  end interface

  interface
    subroutine plumed_f_create_dlopen(path,c) bind(C)
      import
      character(kind=c_char), intent(in)  :: path(*)
      character(kind=c_char), intent(out) :: c(32)
    end subroutine plumed_f_create_dlopen
  end interface

  interface
    subroutine plumed_f_create_reference(r,c) bind(C)
      import
      character(kind=c_char), intent(in)  :: r(32)
      character(kind=c_char), intent(out) :: c(32)
    end subroutine plumed_f_create_reference
  end interface

  interface
    subroutine plumed_f_create_invalid(c) bind(C)
      import
      character(kind=c_char), intent(out) :: c(32)
    end subroutine plumed_f_create_invalid
  end interface

  interface
    subroutine plumed_f_finalize(c) bind(C)
      import
      character(kind=c_char), intent(in) :: c(32)
    end subroutine plumed_f_finalize
  end interface

  interface
    subroutine plumed_f_installed(i) bind(C)
      import
      integer(kind=c_int), intent(out) :: i
    end subroutine plumed_f_installed
  end interface

  interface
    subroutine plumed_f_valid(c,i) bind(C)
      import
      character(kind=c_char), intent(in) :: c(32)
      integer(kind=c_int),    intent(out) :: i
    end subroutine plumed_f_valid
  end interface

  interface
    subroutine plumed_f_use_count(c,i) bind(C)
      import
      character(kind=c_char), intent(in)  :: c(32)
      integer(kind=c_int),    intent(out) :: i
    end subroutine plumed_f_use_count
  end interface

  interface
    subroutine plumed_f_global(c) bind(C)
      import
      character(kind=c_char), intent(out) :: c(32)
    end subroutine plumed_f_global
  end interface 

  interface
    subroutine plumed_f_ginitialized(i) bind(C)
      import
      integer(kind=c_int), intent(out) :: i
    end subroutine plumed_f_ginitialized
  end interface

  interface
    subroutine plumed_f_gcreate() bind(C)
    end subroutine plumed_f_gcreate
  end interface
  
  interface
    subroutine plumed_f_gfinalize() bind(C)
    end subroutine plumed_f_gfinalize
  end interface

  interface
    subroutine plumed_f_gvalid(i) bind(C)
      import
      integer(kind=c_int),    intent(out) :: i
    end subroutine plumed_f_gvalid
  end interface

  interface
    subroutine plumed_f_cmd_safe_char(p,key,val,pass_shape) bind(C)
      import
      character(kind=c_char), intent(in)    :: p(32)
      character(kind=c_char), intent(in)    :: key(*)
      character(kind=c_char)                :: val(*)
      integer(kind=c_size_t) :: pass_shape(*)
    end subroutine plumed_f_cmd_safe_char
  end interface

  interface
    subroutine plumed_f_gcmd_safe_char(key,val,pass_shape) bind(C)
      import
      character(kind=c_char), intent(in)    :: key(*)
      character(kind=c_char)                :: val(*)
      integer(kind=c_size_t) :: pass_shape(*)
    end subroutine plumed_f_gcmd_safe_char
  end interface

  interface plumed_f_cmd
    module procedure plumed_f_cmd_char
#: for t in types
#: for ik in range(len(kinds[t]))
#: for r in range(maxrank+1)
    module procedure plumed_f_cmd_${t}$_${ik}$_${r}$
#: endfor
#: endfor
#: endfor
  end interface plumed_f_cmd

  interface plumed_f_gcmd
    module procedure plumed_f_gcmd_char
#: for t in types
#: for ik in range(len(kinds[t]))
#: for r in range(maxrank+1)
    module procedure plumed_f_gcmd_${t}$_${ik}$_${r}$
#: endfor
#: endfor
#: endfor
  end interface plumed_f_gcmd

#: for t in types
#: for k in kinds[t]
  interface
    subroutine plumed_f_cmd_safe_${cname(k)}$_scalar(p,key,val,pass_shape) bind(C)
      import
      character(kind=c_char), intent(in)    :: p(32)
      character(kind=c_char), intent(in)    :: key(*)
      ${t}$(kind=${k}$)                           :: val
      integer(kind=c_size_t) :: pass_shape(*)
    end subroutine plumed_f_cmd_safe_${cname(k)}$_scalar
  end interface
  interface
    subroutine plumed_f_cmd_safe_${cname(k)}$(p,key,val,pass_shape) bind(C)
      import
      character(kind=c_char), intent(in)    :: p(32)
      character(kind=c_char), intent(in)    :: key(*)
      ${t}$(kind=${k}$)                           :: val(*)
      integer(kind=c_size_t) :: pass_shape(*)
    end subroutine plumed_f_cmd_safe_${cname(k)}$
  end interface
  interface
    subroutine plumed_f_gcmd_safe_${cname(k)}$_scalar(key,val,pass_shape) bind(C)
      import
      character(kind=c_char), intent(in)    :: key(*)
      ${t}$(kind=${k}$)                           :: val
      integer(kind=c_size_t) :: pass_shape(*)
    end subroutine plumed_f_gcmd_safe_${cname(k)}$_scalar
  end interface
  interface
    subroutine plumed_f_gcmd_safe_${cname(k)}$(key,val,pass_shape) bind(C)
      import
      character(kind=c_char), intent(in)    :: key(*)
      ${t}$(kind=${k}$)                           :: val(*)
      integer(kind=c_size_t) :: pass_shape(*)
    end subroutine plumed_f_gcmd_safe_${cname(k)}$
  end interface
#: endfor
#: endfor

  contains

     subroutine pl_create(this)
       class(plumed), intent(out) :: this
       call plumed_f_create(this%handle)
       this%initialized=.true.
     end subroutine pl_create

     subroutine pl_create_reference(this,that)
       class(plumed),                intent(out) :: this
       class(plumed),                intent(in)  :: that
       if(that%initialized) then
         call plumed_f_create_reference(that%handle,this%handle)
         this%initialized=.true.
       endif
     end subroutine pl_create_reference

     subroutine pl_create_dlopen(this,path)
       class(plumed),                intent(out) :: this
       character(kind=c_char,len=*), intent(in)  :: path
       call plumed_f_create_dlopen(path // c_null_char,this%handle)
       this%initialized=.true.
     end subroutine pl_create_dlopen

     subroutine pl_create_invalid(this)
       class(plumed), intent(out) :: this
       call plumed_f_create_invalid(this%handle)
       this%initialized=.true.
     end subroutine pl_create_invalid

     subroutine pl_finalize(this)
       class(plumed), intent(inout) :: this
       if(this%initialized) then
         call plumed_f_finalize(this%handle)
         this%initialized=.false.
       endif
     end subroutine pl_finalize

     ! "impure elemental" needed for the destructor to work on arrays
     impure elemental subroutine pl_destructor(this)
       type(plumed), intent(inout) :: this
       call this%finalize()
     end subroutine pl_destructor

     function pl_valid(this) result(valid)
       class(plumed), intent(inout) :: this
       logical :: valid
       integer(c_int) :: i
       if(.not.this%initialized) then
         call this%create()
       endif
       call plumed_f_valid(this%handle,i)
       valid=i>0
     end function pl_valid

     function pl_use_count(this) result(use_count)
       class(plumed), intent(inout) :: this
       integer(c_int) :: use_count
       if(.not.this%initialized) then
         call this%create()
       endif
       call plumed_f_use_count(this%handle,use_count)
     end function pl_use_count

     subroutine pl_assign(this,that)
       class(plumed),intent(inout) :: this
       class(plumed),intent(in)    :: that
       call this%create_reference(that)
     end subroutine pl_assign

     subroutine pl_cmd(this,key)
       class(plumed),                 intent(inout) :: this ! inout to allow for initialization
       character(kind=c_char,len=*),  intent(in)    :: key
       if(.not.this%initialized) then
         call this%create()
       endif
       call plumed_f_cmd(this%handle,key // c_null_char,0) ! FIX: replace this to send NULL
     end subroutine pl_cmd

     subroutine pl_cmd_char(this,key,val)
       class(plumed),                 intent(inout) :: this ! inout to allow for initialization
       character(kind=c_char,len=*),  intent(in)    :: key
       character(kind=c_char,len=*), asynchronous   :: val
       if(.not.this%initialized) then
         call this%create()
       endif
       call plumed_f_cmd(this%handle,key // c_null_char,val // c_null_char)
     end subroutine pl_cmd_char

#: for t in types
#: for ik in range(len(kinds[t]))
#: set k = kinds[t][ik]
#: for r in range(maxrank+1)
    subroutine pl_cmd_${t}$_${ik}$_${r}$(this,key,val)
      class(plumed),                 intent(inout) :: this ! inout to allow for initialization
      character(kind=c_char,len=*),  intent(in)    :: key
      ${t}$(KIND=${k}$), asynchronous              :: val${ranksuffix(r)}$
       if(.not.this%initialized) then
         call this%create()
       endif
       call plumed_f_cmd(this%handle,key // c_null_char,val)
    end subroutine pl_cmd_${t}$_${ik}$_${r}$
#: endfor
#: endfor
#: endfor

     subroutine plumed_f_cmd_char(p,key,val)
       character(kind=c_char,len=32), intent(in)    :: p
       character(kind=c_char,len=*),  intent(in)    :: key
       character(kind=c_char,len=*), asynchronous   :: val
       integer(kind=c_size_t) :: pass_shape(2)
       pass_shape=(/len(val),0/)
       call plumed_f_cmd_safe_char(p,key,val,pass_shape)
     end subroutine plumed_f_cmd_char

     subroutine plumed_f_gcmd_char(key,val)
       character(kind=c_char,len=*),  intent(in)    :: key
       character(kind=c_char,len=*), asynchronous   :: val
       integer(kind=c_size_t) :: pass_shape(2)
       pass_shape=(/len(val),0/)
       call plumed_f_gcmd_safe_char(key,val,pass_shape)
     end subroutine plumed_f_gcmd_char

#: for t in types
#: for ik in range(len(kinds[t]))
#: set k = kinds[t][ik]
#: for r in range(maxrank+1)
    subroutine plumed_f_cmd_${t}$_${ik}$_${r}$(p,key,val)
      character(kind=c_char,len=32), intent(in)    :: p
      character(kind=c_char,len=*),  intent(in)    :: key
      ${t}$(KIND=${k}$), asynchronous              :: val${ranksuffix(r)}$
#: if r==0
      integer(kind=c_size_t) :: pass_shape(2)
      pass_shape=(/1,0/)
      call plumed_f_cmd_safe_${cname(k)}$_scalar(p,key,val,pass_shape)
#: else
      integer(kind=c_size_t) :: pass_shape(${r+1}$)
#: for rr in range(r)
      pass_shape(${rr+1}$)=size(val,${r-rr}$)
#: endfor
      pass_shape(${r+1}$)=0
      call plumed_f_cmd_safe_${cname(k)}$(p,key,val,pass_shape)
#: endif
    end subroutine plumed_f_cmd_${t}$_${ik}$_${r}$
    subroutine plumed_f_gcmd_${t}$_${ik}$_${r}$(key,val)
      character(kind=c_char,len=*),  intent(in)    :: key
      ${t}$(kind=${k}$), asynchronous              :: val${ranksuffix(r)}$
#: if r==0
      integer(kind=c_size_t) :: pass_shape(2)
      pass_shape=(/1,0/)
      call plumed_f_gcmd_safe_${cname(k)}$_scalar(key,val,pass_shape)
#: else
      integer(kind=c_size_t) :: pass_shape(${r+1}$)
#: for rr in range(r)
      pass_shape(${rr+1}$)=size(val,${r-rr}$)
#: endfor
      pass_shape(${r+1}$)=0
      call plumed_f_gcmd_safe_${cname(k)}$(key,val,pass_shape)
#: endif
    end subroutine plumed_f_gcmd_${t}$_${ik}$_${r}$
#: endfor
#: endfor
#: endfor

end module plumed_module

